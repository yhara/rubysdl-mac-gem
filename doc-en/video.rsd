= Video
* ((<Video Subsystem Outline>))
* ((<SDL::Screen>))
* ((<SDL::Surface>))
* ((<SDL::VideoInfo>))
* ((<Color, PixelFormat and Pixel value>))

* Methods
TOC

== Video Subsystem Outline
SDL presents a very simple interface to the display framebuffer.
The framebuffer is represented as an offscreen surface to which
you can write directly. If you want the screen to show what you
have written, call the @[update|Screen#update_rect]
function which will guarantee that
the desired portion of the screen is updated.

Before you call any of the SDL video functions, you must first
call @[init](SDL::INIT_VIDEO), which initializes the video and
events in the SDL library. 

If you use both sound and video in your application, you need to
call @[init](SDL::INIT_AUDIO | SDL::INIT_VIDEO) before opening
the sound device, otherwise under Win32 DirectX, you won't be
able to set full-screen display modes.

After you have initialized the library, you can start up the
video display in a number of ways. The easiest way is to pick a
common screen resolution and depth and just initialize the
video, checking for errors. You will probably get what you want,
but SDL may be emulating your requested mode and converting the
display on update. The best way is to @[query|Screen.info], 
for the best video
mode closest to the desired one, and then 
@[convert|Surface#display_format] your images to 
that pixel format.

SDL currently supports any bit depth >= 8 bits per pixel. 8 bpp
formats are considered 8-bit palettized modes, while 12, 15, 16,
24, and 32 bits per pixel are considered "packed pixel" modes,
meaning each pixel contains the RGB color components packed in
the bits of the pixel.

After you have initialized your video mode, you can take the
surface that was returned, and write to it like any other
framebuffer, calling the update routine as you go.

== SDL::Surface
Graphical Surface class.

This class represent areas of "graphical" memory, memory that
can be drawn to. 

METHODS(Surface)

== SDL::Screen
Video framebuffer class. 

This class is subclass of @[Surface], and contents 
is shown in display.

The video framebuffer is returned by 
@[Screen.open] and @[Screen.get].

METHODS(Screen)

== SDL::VideoInfo
Video Target information class.

The instance of this class is returned by @[Screen.info]. It
contains information on either the 'best' available mode (if
called before @[Screen.open]) or the current video mode.

This class has following methods.

--- SDL::VideoInfo#hw_available

    Is it possible to create hardware surfaces?

--- SDL::VideoInfo#wm_available
    
    Is there a window manager available?

--- SDL::VideoInfo#blit_hw
    
    Are hardware to hardware blits accelerated?

--- SDL::VideoInfo#blit_hw_CC
    
    Are hardware to hardware colorkey blits accelerated?

--- SDL::VideoInfo#blit_hw_A
    
    Are hardware to hardware alpha blits accelerated?

--- SDL::VideoInfo#blit_sw
    
    Are software to hardware blits accelerated?

--- SDL::VideoInfo#blit_sw_CC
    
    Are software to hardware colorkey blits accelerated?

--- SDL::VideoInfo#blit_sw_A
    
    Are software to hardware alpha blits accelerated?

--- SDL::VideoInfo#blit_fill
    
    Are color fills accelerated?

--- SDL::VideoInfo#video_mem
    
    Total amount of video memory in Kilobytes

--- SDL::VideoInfo#bpp
    
    bits per pixel of the video device

== SDL::PixelFormat
Surface format information class.
Please see ((<Color, PixelFormat and Pixel value>)).

METHODS(PixelFormat)

== Color, PixelFormat and Pixel value

=== Outline
In Ruby/SDL, color is described as four elements
of 8-bit unsigned interger(from 0 to 255), Red, Green,
Blue and Alpha. In Ruby/SDL, this values are
packed as unsigned n-bit integer(n=8,16,24,32).
The rules of this conversion is called PixelFormat
and converted n-bit integer is called pixel value.
Each surface has one PixelFormat, and you can use
@[Surface#format] to get PixelFormat from surface object.
You can also covert from or to pixel values calling
@[PixelFormat#map_rgb], @[PixelFormat#map_rgba],
@[PixelFormat#get_rgb] and @[PixelFormat#get_rgba].
You can use pixel value or 3 elements array 
or 4 elements array as color parameter.
Return values are normally pixel values.

=== Details
Not documented yet.

== Video Methods 
%%%
NAME get_video_surface
TYPE .
PURPOSE returns the current display surface
RVAL Screen
OBSOLETE Screen.get

PROTO
get_video_surface
getVideoSurface

%%
NAME get
MOD Screen
TYPE .
PURPOSE returns the current display surface
RVAL Screen

PROTO
get

DESC
This method returns the current display surface.
If SDL is doing format conversion on the display surface, this
method returns the publicly visible surface, not the real
video surface.

RET
Returns the instance of @[Screen].

EXCEPTION *

%%
NAME video_info
TYPE .
PURPOSE returns information about the video hardware
RVAL VideoInfo
OBSOLETE Screen.info

PROTO
video_info
videoInfo

%%
NAME info
MOD Screen
TYPE .
PURPOSE returns information about the video hardware
RVAL VideoInfo

PROTO
info

DESC
This function returns a @[information|VideoInfo] about
the video hardware. If this is called before @[Screen.open],
bpp attribute of the returned object will contain the pixel
format of the "best" video mode.

RET
Returns the instance of @[VideoInfo].

EXCEPTION *

SEEALSO
Screen.open
VideoInfo

%%
NAME video_driver_name
TYPE .
PURPOSE Obtain the name of the video driver
RVAL String
OBSOLETE Screen.driver_name

PROTO
video_driver_name
videoDriverName

%%
NAME driver_name
MOD Screen
TYPE .
PURPOSE Obtain the name of the video driver
RVAL String

PROTO
driver_name
driverName

DESC
The driver name is a simple one
word identifier like "x11" or "windib".

RET
Returns driver name as string.

EXCEPTION
Raises @[Error] if video has not been initialized with 
@[init].

SEEALSO
init

%%
NAME list_modes
TYPE .
PURPOSE Returns an array of available screen dimensions for the given format and video flags
RVAL nil/true/Array of [UINT, UINT]
OBSOLETE Screen.list_modes

PROTO
list_modes(flags)
listModes(flags)

%%
NAME list_modes
MOD Screen
TYPE .
PURPOSE Returns an array of available screen dimensions for the given format and video flags
RVAL nil/true/Array of [UINT, UINT]

PROTO
list_modes(flags)
listModes(flags)

DESC
Return an array of available screen dimensions for
the given format and video flags, sorted largest to smallest.

Returns nil if there are no dimensions available for a
particular format, or true if any dimension is okay for the given
format.
The flag parameter is an OR'd
combination of surface flags. The flags are the same as those
used @[Screen.open] and they play a strong role in deciding
what modes are valid.
For instance, if you pass SDL::HWSURFACE as
a flag only modes that support hardware video surfaces will be
returned.

EXAMPLE
# Get available fullscreen/hardware modes
modes = SDL::Screen.list_modes(SDL::FULLSCREEN|SDL::HWSURFACE)

# Check is there are any modes available
if modes == nil
  puts "No modes available!"
  exit 1
end

# Check is there are any modes available
if modes == true
  puts "All resolutions available."
else
  # Print valid modes
  puts "Available Modes"
  modes.each{|w, h| puts "  #{w} x #{h}"}
end

SEEALSO
Screen.open
Screen.info

%%
NAME check_video_mode
TYPE .
PURPOSE Check to see if a particular video mode is supported.
RVAL Integer
OBSOLETE Screen.check_mode

PROTO
check_video_mode(w,h,bpp,flags)
checkVideoMode(w,h,bpp,flags)

%%
NAME check_mode
MOD Screen
TYPE .
PURPOSE Check to see if a particular video mode is supported.
RVAL Integer

PROTO
check_mode(w,h,bpp,flags)
checkMode(w,h,bpp,flags)

DESC
Returns 0 if the requested mode is not supported
under any bit depth,
or returns the bits-per-pixel of the
closest available mode with the given width, height and
requested surface flags (see @[Screen.open]).

The bits-per-pixel value returned is only a suggested mode. You
can usually request and bpp you want when 
@[setting|Screen.opn] the video mode
and SDL will emulate that color depth with a shadow video
surface.


EXAMPLE
puts "Checking mode 640x480@16bpp."
bpp = SDL::Screen.check_mode(640, 480, 16, SDL::HWSURFACE)
if bpp == 0
  puts "Mode not available."
  exit 1
end

puts "SDL Recomemends 640x480@#{bpp}bpp."
screen = SDL::Screen.open(640, 480, bpp, SDL_HWSURFACE)

SEEALSO
Screen.open
Screen.info

%%
NAME set_video_mode
TYPE .
PURPOSE Set up a video mode with the specified width, height and bits-per-pixel.
RVAL Screen
OBSOLETE Screen.open

PROTO
setVideoMode(w,h,bpp,flags)
set_video_mode(w,h,bpp,flags)

%%
NAME open
MOD Screen
TYPE .
PURPOSE Set up a video mode with the specified width, height and bits-per-pixel.
RVAL Screen

PROTO
open(w,h,bpp,flags)

DESC
Set up a video mode with the specified width, height and
bits-per-pixel.

If bpp is 0, it is treated as the current display bits per
pixel.

The flags parameter is the same as the @[Surface#flags]
OR'd combinations of the following values
are valid.

:SDL::SWSURFACE
  Create the video surface in system memory
:SDL::HWSURFACE
  Create the video surface in video memory
:SDL::ASYNCBLIT
  Enables the use of asynchronous updates of the
  display surface. This will usually slow down
  blitting on single CPU machines, but may
  provide a speed increase on SMP systems.
:SDL::ANYFORMAT
  Normally, if a video surface of the requested
  bits-per-pixel ($[bpp]) is not available, SDL will
  emulate one with a shadow surface. Passing
  SDL_ANYFORMAT prevents this and causes SDL to
  use the video surface, regardless of its pixel
  depth.
:SDL::HWPALETTE
  Give SDL exclusive palette access. Without this
  flag you may not always get the the colors you
  request with @[Surface#set_colors] or @[Surface#set_palette].
:SDL::DOUBLEBUF
  Enable hardware double buffering; only valid
  with SDL::HWSURFACE. Calling @[Screen#flip] will flip
  the buffers and update the screen. All drawing
  will take place on the surface that is not
  displayed at the moment. If double buffering
  could not be enabled then @[Screen#flip] will just
  perform a @[Screen#update_rect] on the entire screen.
:SDL::FULLSCREEN
  SDL will attempt to use a fullscreen mode. If a
  hardware resolution change is not possible (for
  whatever reason), the next higher resolution
  will be used and the display window centered on
  a black background.
:SDL::OPENGL
  Create an OpenGL rendering context. You should
  have previously set OpenGL video attributes
  with @[GL.set_attr].
:SDL::OPENGLBLIT
  Create an OpenGL rendering context, like above,
  but allow normal blitting operations. The
  screen (2D) surface may have an alpha channel,
  and @[Screen.update_rect] must be used for updating
  changes to the screen surface. NOTE: This
  option is kept for compatibility only, and is
  ((*not recommended*)) for new code.

:SDL::RESIZABLE
  Create a resizable window. When the window is
  resized by the user a @[Event::VideoResize] event is
  generated and @[Screen.open] can be called
  again with the new size.
:SDL::NOFRAME
  If possible, SDL::NOFRAME causes SDL to create a
  window with no title bar or frame decoration.
  Fullscreen modes automatically have this flag
  set.

NOTES
Whatever flags @[Screen.open] could satisfy are set
in the $[Surface#flags] of the returned surface.

The $[bpp] parameter is the number of bits per pixel, so
a $[bpp] of 24 uses the packed representation of 3 bytes/pixel.
For the more common 4 bytes/pixel mode, use a $[bpp] of 32.
Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel
mode, but different pixel formats.

RET
Returns the framebuffer surface as instace of @[Screen].

EXCEPTION *
SEEALSO
Surface#lock
Surface#set_colors
Screen#flip
Screen

%%
NAME update_rect
MOD Screen
TYPE #
PURPOSE Makes sure the given area is updated on the given screen.

PROTO
updateRect(x,y,w,h)
update_rect(x,y,w,h)

DESC
Makes sure the given area is updated on the given screen. The
rectangle must be confined within the screen boundaries (no
clipping is done).

If $[x], $[y], $[w] and $[h] are all 0, this method
update the entire screen.

This method should not be called while screen is
$[locked|Surface#lock].

SEEALSO
Surface#lock
Screen#update_rects

%%
NAME update_rects
MOD Screen
TYPE #
PURPOSE Makes sure the given list of rectangles is updated on the given screen

PROTO
update_rects(*rects)
updateRects(*rects)

DESC
Makes sure the given list of rectangles is updated on the given
screen. Each rectangle parameter should be an array
of 4 elements as [x, y, w, h].
The rectangles must all be confined within the screen
boundaries (no clipping is done).

This method should not be called while screen($[self]),
is @[locked|Surface#lock].

SEEALSO
Surface#lock
Screen#update_rect

%%
NAME flip
MOD Screen
TYPE #
PURPOSE Swaps screen buffers

PROTO
flip

DESC
On hardware that supports double-buffering, this function sets
up a flip and returns. The hardware will wait for vertical
retrace, and then swap video buffers before the next video
surface blit or lock will return. On hardware that doesn't
support double-buffering, this is equivalent to calling 
$[self].@[update_rect|Screen#update_rect](0, 0, 0, 0)

EXCEPTION *

SEEALSO
set_video_mode
Screen#update_rect

%%
NAME set_colors
MOD Surface
TYPE #
PURPOSE Sets a portion of the colormap for the given 8-bit surface.
RVAL true/false

PROTO
set_colors(colors,firstcolor)
setColors(colors,firstcolor)

DESC
Sets a portion of the colormap for the given 8-bit surface.

When $[self] is the surface associated with the current display,
the display colormap will be updated with the requested colors.
If SDL::HWPALETTE was set in @[Screen.open] flags,
this method will always return true, and the palette is
guaranteed to be set the way you desire, even if the window
colormap has to be warped or run under emulation.

$[colors] is array of colors, one color has three componets,
R, G, B and each component is 8-bits in size.

Palettized (8-bit) screen surfaces with the SDL::HWPALETTE flag
have two palettes, a logical palette that is used for mapping
blits to/from the surface and a physical palette (that
determines how the hardware will map the colors to the display).
SDL_SetColors modifies both palettes (if present), and is
equivalent to calling @[Surface#set_palette] 
with the flags set to (SDL::OGPAL | SDL::PHYSPAL).

RET
If $[self] is not a palettized surface, this method does
nothing, returning false.
If all of the colors were set as passed to
this method, it will return true.
If not all the color entries
were set exactly as given, it will return false,
and you should look
at the surface palette to determine the actual color palette.

EXAMPLE
# Create a display surface with a grayscale palette

# Fill colors with color information
colors = Array.new(256){|i| [i, i, i]}
# Create display
screen = SDL::Screen.open(640, 480, 8, SDL::HWPALETTE)

# Set palette
screen.set_colors(colors, 0)

SEEALSO
Surface#set_palette
Screen.open

%%
NAME set_palette
MOD Surface
TYPE #
PURPOSE Sets the colors in the palette of an 8-bit surface
RVAL true/false

PROTO
set_palette(flags,colors,firstcolor)
setPalette(flags,colors,firstcolor)

DESC
Sets a portion of the palette for the given 8-bit surface.

Palettized (8-bit) screen surfaces with the SDL::HWPALETTE flag
have two palettes, a logical palette that is used for mapping
blits to/from the surface and a physical palette (that
determines how the hardware will map the colors to the display).
@[Surface.blit] always uses the logical palette when blitting
surfaces (if it has to convert between surface pixel formats).
Because of this, it is often useful to modify only one or the
other palette to achieve various special color effects (e.g.,
screen fading, color flashes, screen dimming).

This method can modify either the logical or physical palette
by specifing SDL::LOGPAL or SDL::PHYSPALthe in the $[flags]
parameter.

When $[self] is the surface associated with the current display,
the display colormap will be updated with the requested colors.
If SDL::HWPALETTE was set in @[Screen.open] flags,
this method will always return true, and the palette is
guaranteed to be set the way you desire, even if the window
colormap has to be warped or run under emulation.

$[colors] is array of colors, one color has three componets,
R, G, B and each component is 8-bits in size.

RET
If surface is not a palettized surface, this function does
nothing, returning false.
If all of the colors were set as passed to
this method, it will return true.
If not all the color entries
were set exactly as given, it will return false,
 and you should look
at the surface palette to determine the actual color palette.

EXAMPLE
# Create a display surface with a grayscale palette

# Fill colors with color information
colors = Array.new(256){|i| [i, i, i]}
# Create display
screen = SDL::Screen.open(640, 480, 8, SDL::HWPALETTE)

# Setpalette
screen.set_palette(SDL::LOGPAL|SDL::PHYSPAL, colors, 0)

SEEALSO
Surface#set_colors
Screen.open

%%
NAME set_gamma
TYPE .
PURPOSE Sets the color gamma function for the display
OBSOLETE Screen.set_gamma

PROTO
set_gamma(redgamma,greengamma,bluegamma)
setGamma(redgamma,greengamma,bluegamma)

%%
NAME set_gamma
MOD Screen
TYPE .
PURPOSE Sets the color gamma function for the display

PROTO
set_gamma(redgamma,greengamma,bluegamma)
setGamma(redgamma,greengamma,bluegamma)

DESC
Sets the "gamma function" for the display of each color
component. Gamma controls the brightness/contrast of colors
displayed on the screen. A gamma value of 1.0 is identity (i.e.,
no adjustment is made).

This function adjusts the gamma based on the "gamma function"
parameter, you can directly specify lookup tables for gamma
adjustment with @[Screen.set_gamma_ramp].


EXCEPTION *
NOTES
Not all display hardware is able to change gamma.

SEEALSO
Screen.get_gamma_ramp
Screen.set_gamma_ramp

%%
NAME get_gamma_ramp
TYPE .
PURPOSE Gets the color gamma lookup tables for the display
RVAL Array of UINT
OBSOLETE Screen.get_gamma_ramp

PROTO
get_gamma_ramp
getGammaRamp

%%
NAME get_gamma_ramp
MOD Screen
TYPE .
PURPOSE Gets the color gamma lookup tables for the display
RVAL Array of UINT

PROTO
get_gamma_ramp
getGammaRamp

DESC
Gets the gamma translation lookup tables currently used by the
display. Each table is an array of 256 16bit unsigned integer
values.

RET
Returns an array of 3 elements of an array of 256 16bit unsigned integer.

NOTES
Not all display hardware is able to change gamma.

EXCEPTION *

SEEALSO
Screen.set_gamma
Screen.set_gamma_ramp

%%
NAME set_gamma_ramp
TYPE .
PURPOSE Sets the color gamma lookup tables for the display
OBSOLETE Screen.set_gamma_ramp
PROTO
set_gamma_ramp(table)
setGammaRamp(table)

%%
NAME set_gamma_ramp
MOD Screen
TYPE .
PURPOSE Sets the color gamma lookup tables for the display

PROTO
set_gamma_ramp(tables)
setGammaRamp(tables)

DESC
Sets the gamma lookup tables for the display for each color
component. 
$[tables] parameter is same as @[Screen.get_gamma_ramp],
representing a mapping between the input and output for that
channel. The input is the index into the array, and the output
is the 16-bit gamma value at that index, scaled to the output
color precision. 

This function adjusts the gamma based on lookup tables, you can
also have the gamma calculated based on a "gamma function"
parameter with @[Screen.set_gamma].

EXCEPTION *

SEEALSO
Screen.set_gamma
Screen.get_gamma_ramp

%%
NAME map_rgb
MOD Surface
TYPE #
PURPOSE Map a RGB color value to a pixel format.
RVAL UINT
OBSOLETE PixelFormat#map_rgb

PROTO
map_rgb(r,g,b)
mapRGB(r,g,b)

%%
NAME map_rgb
MOD PixelFormat
TYPE #
PURPOSE RGB Map a RGB color value to a pixel format.
RVAL UINT

PROTO
map_rgb(r,g,b)
mapRGB(r,g,b)

DESC
Maps the RGB color value to the specified pixel format and
returns the pixel value as a 32-bit integer.
$[r], $[g], $[b] should be more than and equal to 0,
and less than or equal to 255.

If the format has a palette (8-bit) the index of the closest
matching color in the palette will be returned.

If the specified pixel format has an alpha component it will be
returned as all 1 bits (fully opaque).

RET
A pixel value best approximating the given RGB color value for a
given pixel format. If the pixel format bpp (color depth) is
less than 32-bpp then the unused upper bits of the return value
can safely be ignored (e.g., with a 16-bpp format the return
value can be assigned to a 16-bit unsigned integer,
and similarly a 8-bit unsigned integer for an 8-bpp format).

SEEALSO
PixelFormat#get_rgb
PixelFormat#get_rgba
PixelFormat#map_rgba
((<Color, PixelFormat and Pixel value>))

%%
NAME map_rgba
MOD Surface
TYPE #
PURPOSE RGBA Map a RGBA color value to a pixel format.
RVAL UINT
OBSOLETE PixelFormat#map_rgba

PROTO
map_rgba(r,g,b,a)
mapRGBA(r,g,b,a)

%%
NAME map_rgba
MOD PixelFormat
TYPE #
PURPOSE Map a RGBA color value to a pixel format.
RVAL UINT

PROTO
map_rgba(r,g,b,a)
mapRGBA(r,g,b,a)

DESC
Maps the RGBA color value to the specified pixel format and
returns the pixel value as a 32-bit integer.
$[r], $[g], $[b] should be more than and equal to 0,
and less than or equal to 255.

If the format has a palette (8-bit) the index of the closest
matching color in the palette will be returned.

If the specified pixel format has no alpha component the alpha
value will be ignored (as it will be in formats with a palette).

RET
A pixel value best approximating the given RGBA color value for a
given pixel format. If the pixel format bpp (color depth) is
less than 32-bpp then the unused upper bits of the return value
can safely be ignored (e.g., with a 16-bpp format the return
value can be assigned to a 16-bit unsigned integer,
and similarly a 8-bit unsigned integer for an 8-bpp format).

SEEALSO
PixelFormat#get_rgb
PixelFormat#get_rgba
PixelFormat#map_rgb
((<Color, PixelFormat and Pixel value>))

%%
NAME get_rgb
MOD Surface
TYPE #
PURPOSE Get RGB values from a pixel in the specified pixel format.
RVAL [UINT, UINT, UINT]
OBSOLETE PixelFormat#get_rgb
PROTO
get_rgb(pixel)
getRGB(pixel)

%%
NAME get_rgb
MOD PixelFormat
TYPE #
PURPOSE Get RGB values from a pixel in the specified pixel format.
RVAL [UINT, UINT, UINT]

PROTO
get_rgb(pixel)
getRGB(pixel)

DESC
Get RGB component values from a pixel stored in the specified
pixel format. It returns an array of 3 elements.

This function uses the entire 8-bit [0..255] range when
converting color components from pixel formats with less than
8-bits per RGB component (e.g., a completely white pixel in
16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8,
0xfc, 0xf8]).

SEEALSO
PixelFormat#get_rgba
PixelFormat#map_rgb
PixelFormat#map_rgba
((<Color, PixelFormat and Pixel value>))

%%
NAME get_rgba
MOD Surface
TYPE #
PURPOSE Get RGBA values from a pixel in the specified pixel format.
RVAL [UINT, UINT, UINT, UINT]
OBSOLETE PixelFormat#get_rgba

PROTO
get_rgba(pixel)
getRGBA(pixel)

%%
NAME get_rgba
MOD PixelFormat
TYPE #
PURPOSE Get RGBA values from a pixel in the specified pixel format.
RVAL [UINT, UINT, UINT, UINT]

PROTO
get_rgba(pixel)
getRGBA(pixel)

DESC
Get RGBA component values as array of four elements 
from a pixel stored in the specified
pixel format.

This function uses the entire 8-bit [0..255] range when
converting color components from pixel formats with less than
8-bits per RGB component (e.g., a completely white pixel in
16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8,
0xfc, 0xf8]).

If the surface has no alpha component, the alpha will be
returned as 0xff (100% opaque).

SEEALSO
PixelFormat#get_rgba
PixelFormat#map_rgb
PixelFormat#map_rgba
((<Color, PixelFormat and Pixel value>))

%%
NAME new
MOD Surface
TYPE .
PURPOSE Create an empty @[Surface]
RVAL Surface

PROTO
new(flags,w,h,depth,Rmask,Gmask,Bmask,Amask)
new(flags,w,h,format)

DESC
Allocate an empty surface 
(must be called after @[Screen.open])

If depth is 8 bits an empty palette is allocated for the
surface, otherwise a 'packed-pixel' format is created
using the $[RGBAmask]'s provided (see @[PixelFormat]). 
The $[flags]
specifies the type of surface that should be created, it is an
OR'd combination of the following possible values.

:SDL::SWSURFACE
  SDL will create the surface in system memory.
  This improves the performance of pixel level
  access, however you may not be able to take
  advantage of some types of hardware blitting.
:SDL::HWSURFACE
  SDL will attempt to create the surface in
  video memory. This will allow SDL to take
  advantage of Video->Video blits (which are
  often accelerated).
:SDL::SRCCOLORKEY
  This flag turns on colourkeying for blits from
  this surface. If SDL::HWSURFACE is also
  specified and colourkeyed blits are
  hardware-accelerated, then SDL will attempt to
  place the surface in video memory. Use
  @[Surface#set_color_key] to set or clear this flag
  after surface creation.
:SDL::SRCALPHA
  This flag turns on alpha-blending for blits
  from this surface. If SDL::HWSURFACE is also
  specified and alpha-blending blits are
  hardware-accelerated, then the surface will be
  placed in video memory if possible. Use
  @[Surface#set_alpha] to set or clear this flag after
  surface creation.

RET
Returns the instance of @[Surface].

EXCEPTION *

NOTES
  Note: If an alpha-channel is specified (that is, if $[Amask] is
  nonzero), then the SDL::SRCALPHA flag is automatically set.
  You may remove this flag by calling @[Surface#set_alpha] after
  surface creation.

EXAMPLE
# Create a 32-bit surface with the bytes of 
# each pixel in R,G,B,A order,
# as expected by OpenGL for textures

big_endian = ([1].pack("N") == [1].pack("L"))

if big_endian
  rmask = 0xff000000
  gmask = 0x00ff0000
  bmask = 0x0000ff00
  amask = 0x000000ff
else
  rmask = 0x000000ff
  gmask = 0x0000ff00
  bmask = 0x00ff0000
  amask = 0xff000000
end

surface = SDL::Surface.new(SDL::SWSURFACE, width, height, 32,
                           rmask, gmask, bmask, amask);

SEEALSO
Surface.new_from
Screen.oepn
Surface#lock
Surface#set_alpha
Surface#set_color_key

%%
NAME new_from
MOD Surface
TYPE .
PURPOSE Create an @[Surface] object from pixel data
RVAL Surface

PROTO
new_from(pixels,w,h,depth,pitch,Rmask,Gmask,Bmask,Amask)

DESC
Creates an @[Surface] object from the provided pixel data.

The data stored in $[pixels](String object)
 is assumed to be of the depth
specified in the parameter list. 
$[pitch] is the length of each scanline in bytes.

See @[Surface.new] for a more detailed description of the
other parameters.

RET
Returns the created surface.

EXCEPTION *

SEEALSO
Surface.new

%%
NAME lock
MOD Surface
TYPE #
PURPOSE Lock a surface for directly access.

PROTO
lock

DESC
This method sets up a surface for directly accessing the pixels. Between calls to @[Surface#lock] 
and @[Surface#unlock] you can write to and read from surface directly.
Once you are done accessing the surface, you should use @[Surface#unlock] to release it.

Not all surfaces require locking. If @[Surface#must_lock?] returns false, then you can read and write to
the surface at any time, and the pixel format of the surface will not change.

No operating system or library calls should be made between lock/unlock pairs, as critical system locks
may be held during this time.

It should be noted, that since SDL 1.1.8 surface locks are recursive. This means that you can lock a
surface multiple times, but each lock must have a match unlock.
  surface.lock
  # Surface is locked
  # Direct pixel access on surface here
  surface.lock
  # More direct pixel access on surface
  surface.unlock
  # Surface is still locked
  # Note: Is versions < 1.1.8, the surface would have been
  # no longer locked at this stage
  surface.unlock
  # Surface is now unlocked

You shoud lock before colling following methods:
* @[Surface#pixels]
LOCKLIST

NOTES
If @[Surface#auto_lock?] returns true, you need not call this method
because Ruby/SDL automatically locks surface when you call methods that 
need locking.

EXCEPTION
Raises @[Error], if the surface couldn't be locked.

SEEALSO
Surface#unlock
Surface#must_lock?
auto_lock?
auto_lock_on
auto_lock_off
auto_lock=

%%
NAME unlock
MOD Surface
TYPE #
PURPOSE Unlocks a previously locked surface.

PROTO
unlock

DESC
Surfaces that were previously locked using @[Surfaces#lock] must be unlocked with @[Surfaces#unlock].
Surfaces should be unlocked as soon as possible.

It should be noted that since 1.1.8, surface locks are recursive.

SEEALSO
Surface#lock

%%
NAME must_lock?
MOD Surface
TYPE #
PURPOSE Get whether the surface require locking or not.
RVAL true/false

PROTO
must_lock?
mustLock?

DESC
Returns true if $[self] require locking for direct access to the pixels, 
otherwise returns false.

SEEALSO
Surface#lock

%%
NAME load_bmp
MOD Surface
TYPE .
PURPOSE Load a Windows BMP file into an SDL_Surface.
RVAL Surface

PROTO
load_bmp(filename)
loadBMP(filename)

DESC
Loads a surface from a named Windows BMP file.

RET
Returns the new @[Surface] object.

EXCEPTION *

SEEALSO
Surface#save_bmp
Surface.load

%%
NAME load_bmp_from_io
MOD Surface
TYPE .
PURPOSE Load a Windows BMP file into an Surface from IO object.
RVAL Surface

PROTO
load_bmp_from_io(io)
loadBMPFromIO(io)

DESC
Loads a surface from a ruby's IO object.
IO object means the ruby object that has following methods:
* read
* rewind
* tell

For example, instances of IO class, StringIO class and Zlib::GZipReader class
are IO object.

RET
Returns the new @[Surface] object.

EXCEPTION *

SEEALSO
Surface.load_bmp
Surface.load_from_io

%%
NAME save_bmp
MOD Surface
TYPE #
PURPOSE Save an SDL_Surface as a Windows BMP file.

PROTO
save_bmp(filename)
saveBMP(filename)

DESC
Saves the $[self] surface as a Windows BMP file named $[filename].

EXCEPTION *
SEEALSO
Surface.load_bmp

%%
NAME destroy
MOD Surface
TYPE #
PURPOSE Frees a Surface

PROTO
destroy

DESC
Frees the resource used by a Surface.
If a surface is destroyed, all operations are forbidden.

SEEALSO
Surface.new
Surface.new_from
Surface#destroyed?

%%
NAME destroyed?
MOD Surface
TYPE #
PURPOSE Returns whether surface is destoryed or not.
RVAL true/false

PROTO
destroyed?

DESC
Returns whether the surface is destroyed by
@[Surface#destroy].

SEEALSO
Surface#destroy

%%
NAME set_color_key
MOD Surface
TYPE #
PURPOSE Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.

PROTO
set_color_key(flag,key)
setColorKey(flag,key)

DESC
Sets the color key (transparent pixel) in a blittable $[surface|Surface]
and enables or disables RLE blit acceleration.
$[key] parameter should be pixel value or color array.

RLE acceleration can substantially speed up blitting 
of images with large horizontal runs of transparent
pixels (i.e., pixels that match the $[key] value). 
The key must be of the same pixel format as the surface,
if pixel value is used.
In that case, @[PixelFormat#map_rgb]
is often useful for obtaining an acceptable value.

If $[flag] is SDL_SRCCOLORKEY then $[key] is the transparent pixel color in the source image of a blit.

If $[flag] is OR'd with SDL::RLEACCEL then the surface will 
be draw using RLE acceleration when drawn with 
@[Surface.blit]. The surface will actually be encoded 
for RLE acceleration the first time @[Surface.blit]
or @[Surface#display_format] is called on the surface.

If $[flag] is 0, this function clears any current color key.

EXCEPTION *
SEEALSO
Surface.blit
Surface#display_format
Surface#map_rgb
Surface#set_alpha
Surface#colorkey

%%
NAME set_alpha
MOD Surface
TYPE #
PURPOSE Adjust the alpha properties of a surface

PROTO
set_alpha(flags,alpha)
setAlpha(flags,alpha)

DESC
This method is used for setting the per-surface alpha value and/or enabling and disabling alpha
blending.

The surface parameter specifies which surface whose 
alpha attributes you wish to adjust. $[flags] is used to
specify whether alpha blending should be used (SDL::SRCALPHA)
 and whether the surface should use RLE
acceleration for blitting (SDL::RLEACCEL). $[flags] 
can be an OR'd combination of these two options, one of
these options or 0. If SDL::SRCALPHA is not passed as a flag
 then all alpha information is ignored when
blitting the surface. The alpha parameter is the 
per-surface alpha value; a surface need not have an
alpha channel to use per-surface alpha and blitting can still be accelerated with SDL::RLEACCEL.

Alpha effects surface blitting in the following ways:

:RGBA->RGB with SDL::SRCALPHA    
  The source is alpha-blended with the destination, using the alpha channel.
  SDL_SRCCOLORKEY and the per-surface alpha are ignored.

:RGBA->RGB without SDL::SRCALPHA
  The RGB data is copied from the source. The source alpha channel and the per-surface
  alpha value are ignored.

:RGB->RGBA with SDL::SRCALPHA
  The source is alpha-blended with the destination using the per-surface alpha value. If
  SDL::SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied. The
  alpha channel of the copied pixels is set to opaque.

:RGB->RGBA without SDL::SRCALPHA
  The RGB data is copied from the source and the alpha value of the copied pixels is set to
  opaque. If SDL::SRCCOLORKEY is set, only the pixels not matching the colorkey value are
  copied.   
                                                                                                         
:RGBA->RGBA with  SDL::SRCALPHA
  The source is alpha-blended with the destination using the source alpha channel. The     
  alpha channel in the destination surface is left untouched. SDL::SRCCOLORKEY is ignored.  

RGBA->RGBA witout SDL::SRCALPHA
  The RGBA data is copied to the destination surface. If SDL::SRCCOLORKEY is set, only the  
  pixels not matching the colorkey value are copied.

RGB->RGB with SDL_SRCALPHA
  The source is alpha-blended with the destination using the per-surface alpha value. If
  SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.

RGB->RGB witout SDL_SRCALPHA
  The RGB data is copied from the source. If SDL_SRCCOLORKEY is set, only the pixels not
  matching the colorkey value are copied.

NOTES
Note: This method and the semantics of SDL alpha blending have changed since version 1.1.4. Up
until version 1.1.5, an alpha value of 0 was considered opaque and a value of 255 was considered
transparent. This has now been inverted: 0 (SDL::ALPHA_TRANSPARENT) is now considered transparent and
255 (SDL::ALPHA_OPAQUE) is now considered opaque.
The per-surface alpha value of 128 is considered a special case and is optimised, so it's much
faster than other per-surface values.

Note that RGBA->RGBA blits (with SDL::SRCALPHA set) keep the alpha of the destination surface.
This means that you cannot compose two arbitrary RGBA surfaces this way and get the result you would
expect from "overlaying" them; the destination alpha will work as a mask.

Also note that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always used
if available

EXCEPTION *
SEEALSO
Surface#map_rgba
Surface#get_rgba
Surface#display_format
Surface.blit
Surface#alpha

%%
NAME set_clip_rect
MOD Surface
TYPE #
PURPOSE Sets the clipping rectangle for a surface.

PROTO
set_clip_rect(x,y,w,h)
setClipRect(x,y,w,h)

DESC
Sets the clipping rectangle for a surface. 
When this surface is the destination of a blit, only the area
within the clip rectangle will be drawn into.

The rectangle pointed to by rect will be clipped to the edges of the surface so that the clip rectangle
for a surface can never fall outside the edges of the surface.

SEEALSO
Surface#get_clip_rect
Surface.blit

%%
NAME get_clip_rect
MOD Surface
TYPE #
PURPOSE Gets the clipping rectangle for a surface.
RVAL [Integer, Integer, UINT, UINT]

PROTO
get_clip_rect
getClipRect

DESC
Gets the clipping rectangle for a surface. When this surface is the destination of a blit, only the area
within the clip rectangle is drawn into.

RET
Returns 4 element array as [x, y, w, h].

SEEALSO
Surface#set_clip_rect
Surface.blit

%%
NAME blit_surface
TYPE .
PURPOSE Performs a fast blit from the source surface to the destination surface.
RVAL 0/-2
OBSOLETE Surface.blit

PROTO
blit_surface(src,srcX,srcY,srcW,srcH,dst,dstX,dstY)
blitSurface(src,srcX,srcY,srcW,srcH,dst,dstX,dstY)


%%
NAME blit
MOD Surface
TYPE .
PURPOSE This performs a fast blit from the source surface to the destination surface.
RVAL 0

PROTO
blit(src,srcX,srcY,srcW,srcH,dst,dstX,dstY)

DESC
This performs a fast blit from the source surface to the destination surface.

$[src] is source surface, $[dst] is destination surface, 
$[srcX], $[srcY], $[srcW], $[srcH] is source rectangle, 
and $[dstX], $[dstY] is destination point.
If all of $[srcX], $[srcY], $[srcW], $[srcH] is zero, the entire surface is copied.

The blit function should not be called on a locked surface.

The results of blitting operations vary greatly depending on whether SDL::SRCAPLHA is set or not. See 
@[Surface#set_alpha] for an explaination of how this 
affects your results. Colorkeying and alpha attributes also
interact with surface blitting, as the following pseudo-code should hopefully explain.

  if source surface has SDL::SRCALPHA set 
    if source surface has alpha channel (that is, Amask != 0)
      blit using per-pixel alpha, ignoring any colour key
    elsif source surface has SDL::SRCCOLORKEY set
      blit using the colour key AND the per-surface alpha value
    else
      blit using the per-surface alpha value
    end
  elsif source surface has SDL::SRCCOLORKEY se
    blit using the colour key
  else
    ordinary opaque rectangular blit
  end

RET
If the blit is successful, it returns 0.

EXCEPTION
If either of the surfaces were in video memory, 
and the blit raises SDL::Surface::VideoMemoryLost,
the video memory was lost, so it
should be reloaded with artwork and re-blitted.

This happens under DirectX 5.0 when the system switches away from your fullscreen application. Locking
the surface will also fail until you have access to the video memory again.

%%
NAME fill_rect
MOD Surface
TYPE #
PURPOSE This function performs a fast fill of the given rectangle with some color

PROTO
fill_rect(x,y,w,h,color)
fillRect(x,y,w,h,color)

DESC
This method performs a fast fill of the given rectangle with $[color].

Please see ((<Color, PixelFormat and Pixel value>)) to specify $[color].
If the color value contains an alpha value then the destination is simply "filled"
with that alpha information, no blending takes place.

If there is a clip rectangle set on the destination (set via @[Surface#set_clip_rect])
then this function will clip based on the intersection of the clip rectangle 
and the dstrect rectangle and the dstrect rectangle
will be modified to represent the area actually filled.

EXCEPTION *
SEEALSO
Surface#map_rgb
Surface#map_rgba
Surface.blit

%%
NAME display_format
MOD Surface
TYPE #
PURPOSE Convert a surface to the display format
RVAL Surface

PROTO
display_format
displayFormat

DESC
This method copies $[self] to a new surface of the pixel format and colors of the video
framebuffer, suitable for fast blitting onto the display surface.

If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the
colorkey and alpha value before calling this function.

If you want an alpha channel, see @[Surface#display_format_alpha].

RET
Returns converted surface object.

EXCEPTION
Raises @[Error] if the conversion fails or runs out of memory.

SEEALSO
Surface#display_format_alpha
Surface#set_alpha
Surface#set_color_key

%%
NAME display_format_alpha
MOD Surface
TYPE #
PURPOSE Convert a surface to the display format
RVAL Surface

PROTO
display_format_alpha
displaFormatAlpha

DESC
This method copies $[self] to a new surface of the pixel format and colors of the video
framebuffer plus an alpha channel, suitable for fast blitting onto the display surface.

If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the
colorkey and alpha value before calling this function.

This function can be used to convert a colourkey to an alpha channel, if the SDL::SRCCOLORKEY flag is set
on the surface. The generated surface will then be transparent (alpha=0) where the pixels match the
colourkey, and opaque (alpha=255) elsewhere.

RET
Returns converted surface object.

EXCEPTION
Raises @[Error] if the conversion fails or runs out of memory.

SEEALSO
Surface#display_format
Surface#set_alpha
Surface#set_color_key

%%
NAME flags
MOD Surface
TYPE #
PURPOSE Get surface flags
RVAL UINT

PROTO
flags

DESC
Returns the surface flags.
The following are supported:

:SDL::SWSURFACE
  Surface is stored in system memory
:SDL::HWSURFACE
  Surface is stored in video memory
:SDL::ASYNCBLIT
  Surface uses asynchronous blits if possible
:SDL::ANYFORMAT
  Allows any pixel-format (Display surface)
:SDL::HWPALETTE
  Surface has exclusive palette
:SDL::DOUBLEBUF
  Surface is double buffered (Display surface)
:SDL::FULLSCREEN
  Surface is full screen (Display Surface)
:SDL::OPENGL
  Surface has an OpenGL context (Display Surface)
:SDL::OPENGLBLIT
  Surface supports OpenGL blitting (Display Surface)
:SDL::RESIZABLE
  Surface is resizable (Display Surface)
:SDL::HWACCEL
  Surface blit uses hardware acceleration
:SDL::SRCCOLORKEY
  Surface use colorkey blitting
:SDL::RLEACCEL
  Colorkey blitting is accelerated with RLE
:SDL::SRCALPHA
  Surface blit uses alpha blending

RET
Returns OR'd compination of above constants.

SEEALSO
Surface
Screen

%%
NAME format
MOD Surface
TYPE #
PURPOSE Get surface pixel format
RVAL PixelFormat

PROTO
format

DESC
Returns @[PixelFormat] object.

%%
NAME w
MOD Surface
TYPE #
PURPOSE Get surface width
RVAL UINT

PROTO
w

DESC
Returns width of the surface.

SEEALSO
Surface#h

%%
NAME h
MOD Surface
TYPE #
PURPOSE Get surface height
RVAL UINT

PROTO
h

DESC
Returns height of the surface

SEEALSO
Surface#w

%%
NAME pixels
MOD Surface
TYPE #
PURPOSE Get the actual pixel data
RVAL String

PROTO
pixels

DESC
Returns pixel data as String object.
Examine @[Surface#flags], @[Surface#pitch] and @[Surface#format]
to analyze pixel data.

NOTES
You must @[lock|Surface#lock] surface before calling this method.

SEEALSO
Surface#flags
Surface#pitch
Surface#format

%%
NAME Rmask
MOD PixelFormat
TYPE #
PURPOSE Get binary mask used to retrieve red color value
RVAL UINT

PROTO
Rmask

DESC
Returns binary mask allowing us to isolate red component.

%%
NAME Gmask
MOD PixelFormat
TYPE #
PURPOSE Get binary mask used to retrieve green color value
RVAL UINT

PROTO
Gmask

DESC
Returns binary mask allowing us to isolate green component.

%%
NAME Bmask
MOD PixelFormat
TYPE #
PURPOSE Get binary mask used to retrieve blue color value
RVAL UINT

PROTO
Bmask

DESC
Returns binary mask allowing us to isolate blue component.

%%
NAME Amask
MOD PixelFormat
TYPE #
PURPOSE Get binary mask used to retrieve alpla value
RVAL UINT

PROTO
Amask

DESC
Returns binary mask allowing us to isolate alpha component.

%%
NAME Rloss
MOD PixelFormat
TYPE #
PURPOSE Precision loss of red component
RVAL UINT

PROTO
Rloss

DESC
Returns the number of bits lost from red component when packing 8-bit color component in a pixel.

%%
NAME Gloss
MOD PixelFormat
TYPE #
PURPOSE Precision loss of green component
RVAL UINT

PROTO
Gloss

DESC
Returns the number of bits lost from green component when packing 8-bit color component in a pixel.

%%
NAME Bloss
MOD PixelFormat
TYPE #
PURPOSE Precision loss of blue component
RVAL UINT

PROTO
Bloss

DESC
Returns the number of bits lost from blue component when packing 8-bit color component in a pixel.

%%
NAME Aloss
MOD PixelFormat
TYPE #
PURPOSE Precision loss of alpha component
RVAL UINT

PROTO
Aloss

DESC
Returns the number of bits lost from alpha component when packing 8-bit color component in a pixel.

%%
NAME Rshift
MOD PixelFormat
TYPE #
PURPOSE Binary left shift of red component in the pixel value
RVAL UINT

PROTO
Rshift

DESC
Returns the number of bits to the right of red component in the pixel value.

%%
NAME Gshift
MOD PixelFormat
TYPE #
PURPOSE Binary left shift of green component in the pixel value
RVAL UINT

PROTO
Gshift

DESC
Returns the number of bits to the right of green component in the pixel value.

%%
NAME Bshift
MOD PixelFormat
TYPE #
PURPOSE Binary left shift of blue component in the pixel value
RVAL UINT

PROTO
Bshift

DESC
Returns the number of bits to the right of blue component in the pixel value

%%
NAME Ashift
MOD PixelFormat
TYPE #
PURPOSE Binary left shift of alpha component in the pixel value
RVAL UINT

PROTO
Ashift

DESC
Returns the number of bits to the right of alpha component in the pixel value.

%%
NAME colorkey
MOD Surface
TYPE #
PURPOSE Pixel value of transparent pixels
RVAL UINT

PROTO
colorkey

DESC
Returns pixel value of transparent pixels.


SEEALSO
Surface
Surface#set_color_key
((<Color, PixelFormat and Pixel value>))

%%
NAME alpha
MOD Surface
TYPE #
PURPOSE Overall surface alpha value
RVAL UINT

PROTO
alpha

DESC
Returns surface alpha value from 0(transparent) to 255(opaque).

SEEALSO
Surface#set_alpha

%%
NAME colorkey
MOD PixelFormat
TYPE #
PURPOSE Pixel value of transparent pixels.
RVAL UINT

PROTO
colorkey

DESC
Returns pixel value of transparent pixels.

SEEALSO
Surface
Surface#set_color_key
((<Color, PixelFormat and Pixel value>))

%%
NAME alpha
MOD PixelFormat
TYPE #
PURPOSE Overall surface alpha value
RVAL UINT

PROTO
alpha

DESC
Returns surface alpha value from 0(transparent) to 255(opaque).

SEEALSO
Surface#set_alpha


%%
NAME bpp
MOD Surface
TYPE #
PURPOSE The number of bits used to represent each pixel in a surface
RVAL UINT
OBSOLETE PixelFormat#bpp

PROTO
bpp

%%
NAME bpp
MOD PixelFormat
TYPE #
PURPOSE The number of bits used to represent each pixel in a surface
RVAL UINT

PROTO
bpp

DESC
Returns the number of bits used to represent each pixel in a surface.
Usually 8, 16, 24 or 32.

%%
NAME load
MOD Surface
TYPE .
DEP SDL_image
PURPOSE Load image into an surface
RVAL Surface

PROTO
load(filename)

DESC
Load image into an surface and returns @[surface|Surface] object.
If image format supports transparent color, colorkey is set into new surfafe.

Supoorted formats are
BMP, PNM (PPM/PGM/PBM), XPM,
XCF, PCX, GIF, JPEG, TIFF, TGA, PNG and LBM.

EXCEPTION *

%%
NAME load_from_io
MOD Surface
TYPE .
PURPOSE Load a image file into an Surface from IO object.
RVAL Surface

PROTO
load_from_io(io)
loadFromIO(io)

DESC
Loads a surface from a ruby's IO object.
IO object means the ruby object that has following methods:
* read
* rewind
* tell

If image format supports transparent color, colorkey is set into new surfafe.
Supoorted formats are
BMP, PNM (PPM/PGM/PBM), XPM,
XCF, PCX, GIF, JPEG, TIFF, TGA, PNG and LBM.

EXCEPTION *

SEEALSO
Surface.load
Surface.load_bmp_from_io

%%
NAME put_pixel
MOD Surface
TYPE #
LOCK
PURPOSE Writes a pixel to the specified position

PROTO
put_pixel(x, y, color)
putPixel(x, y, color)
[]=(x, y, color)

DESC
Writes $[color] pixel at ($[x], $[y]).

SEEALSO
Surface#get_pixel
((<Color, PixelFormat and Pixel value>))

%%
NAME get_pixel
MOD Surface
TYPE #
LOCK
PURPOSE Gets the color of the specified pixel.
RVAL UINT

PROTO
get_pixel(x, y)
getPixel(x, y)
[](x, y)

DESC
Returns pixel value at ($[x], $[y]).

SEEALSO
Surface#put_pixel
((<Color, PixelFormat and Pixel value>))

%%
NAME put
MOD Surface
TYPE #
PURPOSE Performs a fast blit from entire surface.

PROTO
put(src, x, y)

DESC
Performs a fast blit from entire $[src] surface to $[self] at ($[x], $[y]).

This means:
  SDL::Surface.blit(src, 0, 0, src.w, src.h, self, x, y)


SEEALSO
Surface.blit

%%
NAME copy_rect
MOD Surface
TYPE #
PURPOSE Copies a part of surface.

PROTO
copy_rect(x,y,w,h)
copyRect(x,y,w,h)

DESC
Copies a ($[x], $[y], $[w], $[h]) rectangle from $[self] and return new $[surface|Surface] object.

NOTES
This method call @[Surface.blit] internally, therefore you must unlock surface before calling it.

EXCEPTION *

%%
NAME auto_lock?
TYPE .
DEP SGE
PURPOSE Get whether surface is automatically locked
RVAL true/false
OBSOLETE Surface.auto_lock?

PROTO
auto_lock?
autoLock?
auto_lock
autoLock

%%
NAME auto_lock?
MOD Surface
TYPE .
DEP SGE
PURPOSE Get whether surface is automatically locked
RVAL true/false

PROTO
auto_lock?
autoLock?

DESC
Returns true if surface is automatically @[locked|Surface#lock]
when necessary, otherwise returns false.

Default is ON(true).

SEEALSO
Surface#lock
Surface#unlock
Surface.auto_lock_on
Surface.auto_lock_off

%%
NAME auto_lock_on
TYPE .
DEP SGE
PURPOSE Switch on auto locking
OBSOLETE Surface.auto_lock_on

PROTO
auto_lock_on
autoLockON

%%
NAME auto_lock_on
MOD Surface
TYPE .
DEP SGE
PURPOSE Switch on auto locking

PROTO
auto_lock_on
autoLockON

DESC
Enables auto surface locking. 

SEEALSO
Surface#lock
Surface.auto_lock?
Surface.auto_lock_off

%%
NAME auto_lock_off
TYPE .
DEP SGE
PURPOSE Switch off auto locking
OBSOLETE Surface.auto_lock_off

PROTO
auto_lock_off
autoLockOFF

%%
NAME auto_lock_off
MOD Surface
TYPE .
DEP SGE
PURPOSE Switch off auto locking.

PROTO
auto_lock_off
autoLockOFF

DESC
Disables auto surface locking. 

SEEALSO
Surface#lock
Surface.auto_lock?
Surface.auto_lock_on

%%
NAME auto_lock=
TYPE .
DEP SGE
PURPOSE Set auto locking
OBSOLETE Surface.auto_lock_on

PROTO
auto_lock=(locking)
autoLock=(locking)

DESC
Enables or disables auto surface locking.
'SDL.auto_lock = true' is same as @[Surface.auto_lock_on]
and 'SDL.auto_lock = false' is same as 
@[Surface.auto_lock_off].

SEEALSO
Surface#lock
auto_lock?
auto_lock_on
auto_lock_off

%%
NAME transform
TYPE .
DEP SGE
PURPOSE Draw a rotated and scaled image.
OBSOLETE Surface.transform_draw

PROTO
transform(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)

%%
NAME transform_draw
MOD Surface
TYPE .
DEP SGE
PURPOSE Draw a rotated and scaled image.

PROTO
transform_draw(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)

DESC
Draws a rotated and scaled version of $[src] on $[dest].
$[angle] the rotation angle in degrees, 
$[xscale] and $[yscale] are x and y scaling factor,
($[px], $[py]) is the pivot point to rotate around in the $[src],
and ($[qx], $[qy]) is the destination point on $[dst] surface.

$[flags] is OR'd combination of follwing values:

:0
  Default
:SDL::Surface::TRANSFORM_SAFE
  Don't asume that the $[src] and $[dst] surfaces has
  the same pixel format. This is the default when the two
  surfaces don't have the same BPP. This is slower but will
  render wierd pixel formats right.
:SDL::Surface::TRANSFORM_AA
  Use the interpolating renderer. Much slower but
  can look better.
:SDL::Surface::TRANSFORM_TMAP
  Use texture mapping. This is a bit faster but
  the result isn't as nice as in the normal mode. This mode
  will also ignore the px/py coordinates and the other flags.

NOTES
To get optimal performance PLEASE make sure that the two
surfaces has the same pixel format (color depth) and doesn't use
24-bpp.

You can set source and destination clipping rectangles with
@[Surface#set_clip_rect].

If you use the interpolated renderer the image will be
clipped 1 pixel in hight and width (to optimize the
performance).

If you want to transform a 32-bpp RGBA (alpha) surface with
the interpolated renderer, please use the 
SDL::TRANSFORM_SAFE flag.

This function will not do any alpha blending, but it will
try to preserve the alpha channel. If you want to rotate and
alpha blend the result, please use @[Surface.transform_blit]
and then blit that surface to its destination.

SEEALSO
Surface.transform_blit
Surface#transform_surface
Surface.new

%%
NAME transform_blit
TYPE .
DEP SGE
PURPOSE Draw a rotated and scaled image with colorkey and blending
OBSOLETE Surface.transform_blit

PROTO
transform_blit(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)
transformBlit(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)

%%
NAME transform_blit
MOD Surface
TYPE .
DEP SGE
PURPOSE Draw a rotated and scaled image with colorkey and blending

PROTO
transform_blit(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)
transformBlit(src,dst,angle,xscale,yscale,px,py,qx,qy,flags)

DESC
Draw a rotated and scaled image. 
This method is same as @[Surface.transform_draw] except
colorkey and blending are enabled. 

SEEALSO
Surface.transform_draw
Surface#transform_surface
Surface#set_color_key
Surface#set_alpha

%%
NAME draw_line
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draw a line

PROTO
draw_line(x1,x2,y1,y2,color, aa=false, alpha=nil)
drawLine(x1,x2,y1,y2,color, aa=false, alpha=nil)

DESC
Draws a $[color] line from ($[x1], $[y1]) to ($[x2], $[y2]).
If $[aa] is true, draws an antialiased line.
If $[alpha] is integer, draws blended line with alpha value
is $[alpha]. 
If $[alpha] is nil, draws a normal line.

SEEALSO
Surface#draw_rect

%%
NAME draw_aa_line
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draw an antialiased line

PROTO
draw_aa_line(x1,x2,y1,y2,color)
drawAALine(x1,x2,y1,y2,color)

OBSOLETE Surface#draw_line
DESC
Draws a $[color] antialiased line from ($[x1], $[y1]) to ($[x2], $[y2]).

SEEALSO
Surface#draw_line

%%
NAME draw_line_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draw a blended line
OBSOLETE Surface#draw_line

PROTO
draw_line_alpha(x1,x2,y1,y2,color,alpha)
drawLineAlpha(x1,x2,y1,y2,color,alpha)

DESC
Draws a $[color] line from ($[x1], $[y1]) to ($[x2], $[y2])
with blending.

SEEALSO
Surface#draw_line

%%
NAME draw_aa_line_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draw an antialiased line with blending.
OBSOLETE Surface#draw_line

PROTO
draw_aa_line_alpha(x1,x2,y1,y2,color,alpha)
drawAALineAlpha(x1,x2,y1,y2,color,alpha)

DESC
Draws a antialiased $[color] line from 
($[x1], $[y1]) to ($[x2], $[y2]) with blending.


SEEALSO
Surface#draw_line

%%
NAME draw_rect
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a rect

PROTO
draw_rect(x,y,w,h,color, fill=false, alpha=nil)
drawRect(x,y,w,h,color, fill=false, alpha=nil)

DESC
Draws a rectangle with color $[color]. 
Draw a filled rectangle if $[fill] is true,
and a blended rectangle if $[alpha] is integer.

SEEALSO
Surface#fill_rect

%%
NAME draw_rect_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a rectangle with blending
OBSOLETE Surface#draw_rect

PROTO
draw_rect_alpha(x,y,w,h,color,alpha)
drawRectAlpha(x,y,w,h,color,alpha)

DESC
Draws a blended rectangle.

SEEALSO
Surface#fill_rect
Surface#draw_rect

%%
NAME draw_filled_rect_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled blended rectangle.
OBSOLETE Surface#draw_rect

PROTO
draw_filled_rect_alpha(x,y,w,h,color,alpha)
drawFilledRectAlpha(x,y,w,h,color,alpha)

DESC
Draws a filled blended rectangle.

SEEALSO
Surface#fill_rect
Surface#draw_rect

%%
NAME draw_circle
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a circle

PROTO
draw_circle(x,y,r,color,fill=false,aa=false,alpha=0)
drawCircle(x,y,r,color,fill=false,aa=false,alpha=0)

DESC
Draws a circle. ($[x],$[y]) is center, 
$[r] is radius and $[color] is drawing color.
If $[fill] is true, draws a filled circle.
If $[aa] is true, draws an antialiased circle.
If $[alpha] is integer, draws a blended circle.

NOTES
You cannot draw a filled antialiased blended circle.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_filled_circle
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled circle.
OBSOLETE draw_circle

PROTO
draw_filled_circle(x,y,r,color)
drawFilledCircle(x,y,r,color)

DESC
Draws a filled circle.

SEEALSO
Surface#draw_circle

%%
NAME draw_aa_circle
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased circle.
OBSOLETE draw_circle

PROTO
draw_aa_circle(x,y,r,color)
drawAACircle(x,y,r,color)

DESC
Draws an antialiased circle.

SEEALSO
Surface#draw_circle

%%
NAME draw_aa_filled_circle
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled antialiased circle
OBSOLETE draw_circle

PROTO
draw_aa_filled_circle(x,y,r,color)
drawAAFilledCircle(x,y,r,color)

DESC
Draws a filled antialiased circle.

SEEALSO
Surface#draw_circle

%%
NAME draw_circle_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws blended circle
OBSOLETE draw_circle

PROTO
draw_circle_alpha(x,y,r,color,alpha)
drawCircleAlpha(x,y,r,color,alpha)

DESC
Draws blended circle.

SEEALSO
Surface#draw_circle

%%
NAME draw_filled_circle_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled blended circle
OBSOLETE draw_circle

PROTO
draw_filled_circle_alpha(x,y,r,color,alpha)
drawFilledCircleAlpha(x,y,r,color,alpha)

DESC
Draws a filled blended circle.

SEEALSO
Surface#draw_circle

%%
NAME draw_aa_circle_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased blended circle
OBSOLETE draw_circle

PROTO
draw_aa_circle_alpha(x,y,r,color,alpha)
drawAACircleAlpha(x,y,r,color,alpha)

DESC
Draws an antialiased blended circle

SEEALSO
Surface#draw_circle

%%
NAME draw_ellipse
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an ellipse.

PROTO
draw_ellipse(x,y,rx,ry,color, fill=false, aa=false, alpha=nil)
drawEllipse(x,y,rx,ry,color, fill=false, aa=false, alpha=nil) )

DESC

Draws an ellipse. ($[x],$[y]) is center, 
$[rx] is x-radius, $[ry] is y-radius
and $[color] is drawing color.
If $[fill] is true, draws a filled ellipse.
If $[aa] is true, draws an antialiased ellipse.
If $[alpha] is integer, draws a blended ellipse.

NOTES
You cannot draw a filled antialiased blended ellipse.

SEEALSO
Surface#draw_circle

%%
NAME draw_filled_ellipse
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_filled_ellipse(x,y,rx,ry,color)
drawFilledEllipse(x,y,rx,ry,color)

DESC
Draws a filled ellipse.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_aa_ellipse
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_aa_ellipse(x,y,rx,ry,color)
drawAAEllipse(x,y,rx,ry,color)

DESC
Draws an antialiased ellipse.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_aa_filled_ellipse
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled antialiased ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_aa_filled_ellipse(x,y,rx,ry,color)
drawAAFilledEllipse(x,y,rx,ry,color)

DESC
Draws a filled antialiased ellipse.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_ellipse_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a blended ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_ellipse_alpha(x,y,rx,ry,color,alpha)
drawEllipseAlpha(x,y,rx,ry,color,alpha)

DESC
Draws a blended ellipse.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_filled_ellipse_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a filled blended ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_filled_ellipse_alpha(x,y,rx,ry,color,alpha)
drawFilledEllipseAlpha(x,y,rx,ry,color,alpha)

DESC
Draws a filled blended ellipse

SEEALSO
Surface#draw_ellipse

%%
NAME draw_aa_ellipse_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased blended ellipse
OBSOLETE Surface#draw_ellipse

PROTO
draw_aa_ellipse_alpha(x,y,rx,ry,color,alpha)
drawAAEllipseAlpha(x,y,rx,ry,color,alpha)

DESC
Draws an antialiased blended ellipse.

SEEALSO
Surface#draw_ellipse

%%
NAME draw_bezier
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a bezier curve

PROTO
draw_bezier(x1,y1,x2,y2,x3,y3,x4,y4,level,color,aa=false,alpha=nil)
drawBezier(x1,y1,x2,y2,x3,y3,x4,y4,level,color,aa=false,alpha=nil)

DESC
Draws a bezier curve from ($[x1], $[y1]) to ($[x4], $[y4])
with the control points ($[x2], $[y2]) and ($[x3], $[y3]).
$[level] indicates how
good precision the function should use, 4-7 is normal.
If $[aa] is true, draws an antialiased curve.
If $[alpha] is integer, draws blended curve.

%%
NAME draw_aa_bezier
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased bezier curve.
OBSOLETE Surface#draw_bezier

PROTO
draw_aa_bezier(x1,y1,x2,y2,x3,y3,x4,y4,level,color)
drawAABezier(x1,y1,x2,y2,x3,y3,x4,y4,level,color)

DESC
Draws an antialiased bezier curve.

SEEALSO
Surface#draw_bezier

%%
NAME draw_bezier_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws a blended bezier curve.
OBSOLETE Surface#draw_bezier

PROTO
draw_bezier_alpha(x1,y1,x2,y2,x3,y3,x4,y4,level,color,alpha)
drawBezierAlpha(x1,y1,x2,y2,x3,y3,x4,y4,level,color,alpha)

DESC
Draws a blended bezier curve.

SEEALSO
Surface#draw_bezier

%%
NAME draw_aa_bezier_alpha
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Draws an antialiased blended bezier curve
OBSOLETE Surface#draw_bezier

PROTO
draw_aa_bezier_alpha(x1,y1,x2,y2,x3,y3,x4,y4,level,color,alpha)
drawAABezierAlpha(x1,y1,x2,y2,x3,y3,x4,y4,level,color,alpha)

DESC
Draws an antialiased blended bezier curve.

SEEALSO
Surface#draw_bezier

%%
NAME transform_surface
MOD Surface
TYPE #
DEP SGE
LOCK
PURPOSE Creates an rotated an scaled surface
RVAL Surface

PROTO
transform_surface(bgcolor,angle,xscale,yscale,flags)
transformSurface(bgcolor,angle,xscale,yscale,flags)

DESC
Returns a rotated and scaled version of $[self].
See $[Surface.transform_draw] for more information.
$[bgcolor] is background color that new surface have.

The new surface object will have the same depth 
and pixel format as $[self].

EXCEPTION *

SEEALSO
Surface.transform_draw
Surface.transform_blit

